#!/bin/sh

#
# UNIVERSAL BOOKMARK MANAGER
#
# Organizes bookmarks with tags.
#
# Why tags and not directories?
# Because humans tend to organize ideas in a network-like
# fashion. Tags can represent networks, while directories cannot,
# because a file cannot have multiple parent directories.
#

##########
# CONFIG #
##########
# Menu cmd such that the first argument passed is taken as the prompt text.
alias menu="tofi --prompt-text"
# Menu cmd such that the first argument passed is taken as the prompt text,
# and to be used as input field.
# Despite no match, the input is printed to stdout.
alias menu-input="tofi --require-match false --prompt-text"
file="${XDG_DATA_HOME:-$HOME/.local/share}/bookmarks"
##########

alias help="echo \"Choose 'add', 'remove' or 'pick'.\""
alias bookmark_to_pick="cat $file | menu 'Pick: '"
alias bookmark_to_remove="cat $file | menu 'Remove: '"

ask_tag() {
  new_tag="$(printf "$existing_tags" | menu-input "Tag $n: ")"
  if [ -n "$new_tag" ]
  then
    new_tags="$(printf "$tags\n#$new_tag")"
    # If the added tag is new
    if [ -z "$(printf "$new_tags" | sort | uniq -D)" ]
    then
      existing_tags="$(printf "$existing_tags$new_tag" | sort -u)\n"
      tags="$(printf "$new_tags" | sort -u)"
      n="$((n+1))"
    fi
    ask_tag
  fi
}

if [ "$#" -ne 1 ]
then
  echo "Invalid number of arguments."
  help
  exit 1
fi

if [ "$1" = "add" ]
then
  # Add the current selection to the file
  bookmark="$(wl-paste --primary 2> /dev/null)"
  if [ -n "$bookmark" ]
  then
    # Verify existence of bookmark, ignoring any tags
    if grep -q "^$bookmark" "$file"
    then
      notify-send "Already bookmarked!"
    else
      # Prompt for tags, listing existing tags
      existing_tags="$(cat "$file" | grep -Po "(?<= #)[^ ]+" | sort -u)"
      tags=''
      n=1
      ask_tag
      bookmark_with_tags="$bookmark$(printf "$tags" | tr '\n' ' ')"
      echo "$bookmark_with_tags" >> "$file"
      notify-send "Bookmark added!" "$bookmark"
    fi
  else
    notify-send "Clipboard is empty!" "Nothing to bookmark"
  fi
elif [ "$1" = "remove" ]
then
  # Remove the chosen bookmark from the file
  bookmark_with_tags="$(bookmark_to_remove)"
  if [ -n "$bookmark_with_tags" ]
  then
    if sed -i "\|^$bookmark_with_tags$|d" .local/share/bookmarks
    then
      notify-send "Bookmark removed!" "$bookmark_with_tags"
    else
      notify-send "Bookmark does not exist!" "$bookmark_with_tags"
    fi
  fi
elif [ "$1" = "pick" ]
then
  # Let the user choose a bookmark and copy the chosen bookmark
  bookmark_with_tags="$(bookmark_to_pick)"
  if [ -n "$bookmark_with_tags" ]
  then
    if grep -q "^$bookmark_with_tags$" "$file"
    then
      # Copy the bookmark without the tags
      printf "$bookmark_with_tags" | grep -Eo "^[^ ]+" | tr -d '\n' | wl-copy
      notify-send "Bookmark copied!"
    else
      notify-send "Bookmark does not exist!" "$bookmark_with_tags"
    fi
  fi
else
  echo "Unknown option!"
  help
fi
